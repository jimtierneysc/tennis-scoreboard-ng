/**
 * @ngdoc service
 * @name errorsMapper
 * @description
 * Given a hash, return a new hash that groups values together.  Useful for
 * processing the errors hash generated by Rails before displaying the errors.
 * @param {Object} data
 * Input hash.  Values are expected to be strings or string arrays.
 * @param {Array} names
 * Key names to copy.  Values of these keys will be copied to the hash.
 * @param {Object} map
 * Maps original key names to new key names.
 * @param {String} defaultKey
 * Values of the other keys (those not specified in the names param)
 * will be copied to the hash using this key name.  Each value will
 * be prefixed with the original key name.
 */
(function () {
  'use strict';

  angular
    .module('frontendComponents')
    .factory('errorsMapper', factory);

  /** @ngInject */
  function factory() {

    return errorsMapper;

    function errorsMapper(data, names, map, defaultKey) {
      names = names || [];
      map = map || {};
      defaultKey = defaultKey || 'other';

      var result = {};
      angular.forEach(data, function (value, key) {
        var newKey = matchKeyName(key);
        var messages = [];
        if (newKey == null) {
          newKey = defaultKey;
          appendMessages(messages, value, makePrefix(key));
        }
        else {
          appendMessages(messages, value);  // no prefix
        }

        var arr = result[newKey] || [];
        result[newKey] = arr.concat(messages);
      });
      return result;

      function matchKeyName(key) {
        var newKey = null;
        var i = names.indexOf(key);
        if (i >= 0) {
          var match = names[i];
          if (angular.isDefined(map[match]))
            newKey = map[match];
          else
            newKey = match;
        }
        return newKey;
      }

      function appendMessages(messages, value, prefix) {
        prefix = prefix || '';
        if (typeof value == "object")
          angular.forEach(value, function (el) {
            messages.push(prefix + el)
          });
        else
          messages.push(prefix + value);
      }

      function makePrefix(key) {
        var result = key;
        if (result.length > 0) {
          var notAPrefix = [defaultKey, 'base', 'errors']
          if (notAPrefix.indexOf(key) >= 0)
            result = '';
          else {
            if (result.slice(-3) == '_id')
              result = result.slice(0, result.length - 3)
            result = result.replace(/_/g, ' ');
            result = result.charAt(0).toUpperCase() + result.slice(1);
            result = result + ' ';
          }
        }

        return result;
      }
    }
  }
})();
